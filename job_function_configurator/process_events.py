# SPDX-FileCopyrightText: 2023 Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from uuid import UUID

import structlog
from more_itertools import only
from more_itertools import one

from job_function_configurator.autogenerated_graphql_client import GraphQLClient
from job_function_configurator.config import get_settings


logger = structlog.get_logger(__name__)
settings = get_settings()


async def process_engagement_events(mo: GraphQLClient, engagement_uuid: UUID) -> None:
    """
    A function for handling the various events made involving an engagement.
    This involves checking whether the engagement has a job function containing
    sensitive information, and to potentially overwrite this information.

    Args:
        mo: A MO graphql client used to perform queries and mutations to MO.
        engagement_uuid: UUID of the engagement
    """
    logger.info("Processing an engagement event")

    engagement_object_response = await mo.get_engagement(
        engagement_uuid, settings.itsystem_user_key
    )
    # As we lookup by UUID we expect at most 1 result
    engagement_object = only(engagement_object_response.objects)
    # If no objects were found in the GraphQL payload, it was probably a termination.
    if engagement_object is None:
        logger.info("Engagement objects are missing")
        return
    engagement = engagement_object.current
    if engagement is None:
        logger.warn("Engagement current empty")
        return

    person = one(engagement.person)
    has_ituser = bool(person.itusers)

    is_primary = engagement.is_primary
    has_extension2 = bool(engagement.extension_2)

    job_function_blacklisted = engagement.job_function.user_key in settings.blacklisted_keys

    logger.info(f"ITUser was{'' if has_ituser else ' not'} found")
    if is_primary and has_ituser and has_extension2:
        new_job_function = engagement.extension_2
        source = "extension_2"
    elif job_function_blacklisted:
        new_job_function = settings.empty_content_for_extension_field_update
        source = "empty-value"
    else:
        new_job_function = engagement.job_function.name
        source = "job-function"
    logger.info(
        "Found job function source",
        source=source,
        has_ituser=has_ituser,
        is_primary=is_primary,
        has_extension2=has_extension2,
        job_function_blacklisted=job_function_blacklisted,
    )

    if new_job_function is None:
        logger.info("The desired job function is None, clearing the field")
        new_job_function = settings.empty_content_for_extension_field_update

    if engagement.extension_3 == new_job_function:
        logger.info("Engagement already has the desire job function")
        return

    # Use the engagements current "from" date to avoid multiple entries in database.
    update_from_date = engagement.validity.from_
    update_to_date = engagement.validity.to

    # Make a mutation, write the new contents to extension_3
    await mo.update_extension_field(
        engagement_uuid, update_from_date, update_to_date, new_job_function
    )
    logger.info("The job function has been written to extension_3")
